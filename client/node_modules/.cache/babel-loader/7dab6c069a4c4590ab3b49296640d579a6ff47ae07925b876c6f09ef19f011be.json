{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useState, useEffect, useCallback } from 'react';\nimport { savePendingAction, getPendingActions, removePendingAction, cacheData, getCachedData, isOnline } from '../utils/offlineStorage';\nimport API from '../api/auth';\nconst useOfflineSync = () => {\n  _s();\n  const [online, setOnline] = useState(isOnline());\n  const [syncing, setSyncing] = useState(false);\n  const [pendingCount, setPendingCount] = useState(0);\n\n  // Écouter les changements de connexion\n  useEffect(() => {\n    const handleOnline = () => {\n      setOnline(true);\n      syncPendingActions();\n    };\n    const handleOffline = () => setOnline(false);\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Compter les actions en attente\n    getPendingActions().then(actions => setPendingCount(actions.length));\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  // Synchroniser les actions en attente\n  const syncPendingActions = useCallback(async () => {\n    if (syncing) return;\n    setSyncing(true);\n    try {\n      const actions = await getPendingActions();\n      for (const action of actions) {\n        try {\n          await API({\n            method: action.method,\n            url: action.url,\n            data: action.data\n          });\n          await removePendingAction(action.id);\n        } catch (err) {\n          console.error('Sync failed for action:', action, err);\n        }\n      }\n      const remaining = await getPendingActions();\n      setPendingCount(remaining.length);\n    } finally {\n      setSyncing(false);\n    }\n  }, [syncing]);\n\n  // Faire une requête API avec fallback hors ligne\n  const offlineRequest = useCallback(async ({\n    method,\n    url,\n    data,\n    cacheKey\n  }) => {\n    if (isOnline()) {\n      try {\n        const res = await API({\n          method,\n          url,\n          data\n        });\n        // Mettre en cache les GET\n        if (method === 'get' && cacheKey) {\n          await cacheData(cacheKey, res.data);\n        }\n        return res.data;\n      } catch (err) {\n        // Si échec réseau sur GET, tenter le cache\n        if (method === 'get' && cacheKey) {\n          const cached = await getCachedData(cacheKey);\n          if (cached) return cached;\n        }\n        throw err;\n      }\n    } else {\n      if (method === 'get') {\n        // Hors ligne : lire depuis le cache\n        const cached = await getCachedData(cacheKey);\n        if (cached) return cached;\n        throw new Error('Pas de données en cache');\n      } else {\n        // Hors ligne : sauvegarder l'action pour plus tard\n        await savePendingAction({\n          method,\n          url,\n          data\n        });\n        const newCount = (await getPendingActions()).length;\n        setPendingCount(newCount);\n        return {\n          offline: true,\n          message: 'Action sauvegardée, sera synchronisée en ligne'\n        };\n      }\n    }\n  }, []);\n  return {\n    online,\n    syncing,\n    pendingCount,\n    syncPendingActions,\n    offlineRequest\n  };\n};\n_s(useOfflineSync, \"9ofR0PMZiLCftQ8byEYzHcLQ1qk=\");\nexport default useOfflineSync;","map":{"version":3,"names":["useState","useEffect","useCallback","savePendingAction","getPendingActions","removePendingAction","cacheData","getCachedData","isOnline","API","useOfflineSync","_s","online","setOnline","syncing","setSyncing","pendingCount","setPendingCount","handleOnline","syncPendingActions","handleOffline","window","addEventListener","then","actions","length","removeEventListener","action","method","url","data","id","err","console","error","remaining","offlineRequest","cacheKey","res","cached","Error","newCount","offline","message"],"sources":["/Users/yuupeegs/Desktop/APP PROF/prof-senegal/client/src/hooks/useOfflineSync.js"],"sourcesContent":["import { useState, useEffect, useCallback } from 'react';\nimport { savePendingAction, getPendingActions, removePendingAction, cacheData, getCachedData, isOnline } from '../utils/offlineStorage';\nimport API from '../api/auth';\n\nconst useOfflineSync = () => {\n  const [online, setOnline] = useState(isOnline());\n  const [syncing, setSyncing] = useState(false);\n  const [pendingCount, setPendingCount] = useState(0);\n\n  // Écouter les changements de connexion\n  useEffect(() => {\n    const handleOnline = () => {\n      setOnline(true);\n      syncPendingActions();\n    };\n    const handleOffline = () => setOnline(false);\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    // Compter les actions en attente\n    getPendingActions().then((actions) => setPendingCount(actions.length));\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, []);\n\n  // Synchroniser les actions en attente\n  const syncPendingActions = useCallback(async () => {\n    if (syncing) return;\n    setSyncing(true);\n\n    try {\n      const actions = await getPendingActions();\n      for (const action of actions) {\n        try {\n          await API({\n            method: action.method,\n            url: action.url,\n            data: action.data,\n          });\n          await removePendingAction(action.id);\n        } catch (err) {\n          console.error('Sync failed for action:', action, err);\n        }\n      }\n      const remaining = await getPendingActions();\n      setPendingCount(remaining.length);\n    } finally {\n      setSyncing(false);\n    }\n  }, [syncing]);\n\n  // Faire une requête API avec fallback hors ligne\n  const offlineRequest = useCallback(async ({ method, url, data, cacheKey }) => {\n    if (isOnline()) {\n      try {\n        const res = await API({ method, url, data });\n        // Mettre en cache les GET\n        if (method === 'get' && cacheKey) {\n          await cacheData(cacheKey, res.data);\n        }\n        return res.data;\n      } catch (err) {\n        // Si échec réseau sur GET, tenter le cache\n        if (method === 'get' && cacheKey) {\n          const cached = await getCachedData(cacheKey);\n          if (cached) return cached;\n        }\n        throw err;\n      }\n    } else {\n      if (method === 'get') {\n        // Hors ligne : lire depuis le cache\n        const cached = await getCachedData(cacheKey);\n        if (cached) return cached;\n        throw new Error('Pas de données en cache');\n      } else {\n        // Hors ligne : sauvegarder l'action pour plus tard\n        await savePendingAction({ method, url, data });\n        const newCount = (await getPendingActions()).length;\n        setPendingCount(newCount);\n        return { offline: true, message: 'Action sauvegardée, sera synchronisée en ligne' };\n      }\n    }\n  }, []);\n\n  return { online, syncing, pendingCount, syncPendingActions, offlineRequest };\n};\n\nexport default useOfflineSync;"],"mappings":";AAAA,SAASA,QAAQ,EAAEC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACxD,SAASC,iBAAiB,EAAEC,iBAAiB,EAAEC,mBAAmB,EAAEC,SAAS,EAAEC,aAAa,EAAEC,QAAQ,QAAQ,yBAAyB;AACvI,OAAOC,GAAG,MAAM,aAAa;AAE7B,MAAMC,cAAc,GAAGA,CAAA,KAAM;EAAAC,EAAA;EAC3B,MAAM,CAACC,MAAM,EAAEC,SAAS,CAAC,GAAGb,QAAQ,CAACQ,QAAQ,CAAC,CAAC,CAAC;EAChD,MAAM,CAACM,OAAO,EAAEC,UAAU,CAAC,GAAGf,QAAQ,CAAC,KAAK,CAAC;EAC7C,MAAM,CAACgB,YAAY,EAAEC,eAAe,CAAC,GAAGjB,QAAQ,CAAC,CAAC,CAAC;;EAEnD;EACAC,SAAS,CAAC,MAAM;IACd,MAAMiB,YAAY,GAAGA,CAAA,KAAM;MACzBL,SAAS,CAAC,IAAI,CAAC;MACfM,kBAAkB,CAAC,CAAC;IACtB,CAAC;IACD,MAAMC,aAAa,GAAGA,CAAA,KAAMP,SAAS,CAAC,KAAK,CAAC;IAE5CQ,MAAM,CAACC,gBAAgB,CAAC,QAAQ,EAAEJ,YAAY,CAAC;IAC/CG,MAAM,CAACC,gBAAgB,CAAC,SAAS,EAAEF,aAAa,CAAC;;IAEjD;IACAhB,iBAAiB,CAAC,CAAC,CAACmB,IAAI,CAAEC,OAAO,IAAKP,eAAe,CAACO,OAAO,CAACC,MAAM,CAAC,CAAC;IAEtE,OAAO,MAAM;MACXJ,MAAM,CAACK,mBAAmB,CAAC,QAAQ,EAAER,YAAY,CAAC;MAClDG,MAAM,CAACK,mBAAmB,CAAC,SAAS,EAAEN,aAAa,CAAC;IACtD,CAAC;EACH,CAAC,EAAE,EAAE,CAAC;;EAEN;EACA,MAAMD,kBAAkB,GAAGjB,WAAW,CAAC,YAAY;IACjD,IAAIY,OAAO,EAAE;IACbC,UAAU,CAAC,IAAI,CAAC;IAEhB,IAAI;MACF,MAAMS,OAAO,GAAG,MAAMpB,iBAAiB,CAAC,CAAC;MACzC,KAAK,MAAMuB,MAAM,IAAIH,OAAO,EAAE;QAC5B,IAAI;UACF,MAAMf,GAAG,CAAC;YACRmB,MAAM,EAAED,MAAM,CAACC,MAAM;YACrBC,GAAG,EAAEF,MAAM,CAACE,GAAG;YACfC,IAAI,EAAEH,MAAM,CAACG;UACf,CAAC,CAAC;UACF,MAAMzB,mBAAmB,CAACsB,MAAM,CAACI,EAAE,CAAC;QACtC,CAAC,CAAC,OAAOC,GAAG,EAAE;UACZC,OAAO,CAACC,KAAK,CAAC,yBAAyB,EAAEP,MAAM,EAAEK,GAAG,CAAC;QACvD;MACF;MACA,MAAMG,SAAS,GAAG,MAAM/B,iBAAiB,CAAC,CAAC;MAC3Ca,eAAe,CAACkB,SAAS,CAACV,MAAM,CAAC;IACnC,CAAC,SAAS;MACRV,UAAU,CAAC,KAAK,CAAC;IACnB;EACF,CAAC,EAAE,CAACD,OAAO,CAAC,CAAC;;EAEb;EACA,MAAMsB,cAAc,GAAGlC,WAAW,CAAC,OAAO;IAAE0B,MAAM;IAAEC,GAAG;IAAEC,IAAI;IAAEO;EAAS,CAAC,KAAK;IAC5E,IAAI7B,QAAQ,CAAC,CAAC,EAAE;MACd,IAAI;QACF,MAAM8B,GAAG,GAAG,MAAM7B,GAAG,CAAC;UAAEmB,MAAM;UAAEC,GAAG;UAAEC;QAAK,CAAC,CAAC;QAC5C;QACA,IAAIF,MAAM,KAAK,KAAK,IAAIS,QAAQ,EAAE;UAChC,MAAM/B,SAAS,CAAC+B,QAAQ,EAAEC,GAAG,CAACR,IAAI,CAAC;QACrC;QACA,OAAOQ,GAAG,CAACR,IAAI;MACjB,CAAC,CAAC,OAAOE,GAAG,EAAE;QACZ;QACA,IAAIJ,MAAM,KAAK,KAAK,IAAIS,QAAQ,EAAE;UAChC,MAAME,MAAM,GAAG,MAAMhC,aAAa,CAAC8B,QAAQ,CAAC;UAC5C,IAAIE,MAAM,EAAE,OAAOA,MAAM;QAC3B;QACA,MAAMP,GAAG;MACX;IACF,CAAC,MAAM;MACL,IAAIJ,MAAM,KAAK,KAAK,EAAE;QACpB;QACA,MAAMW,MAAM,GAAG,MAAMhC,aAAa,CAAC8B,QAAQ,CAAC;QAC5C,IAAIE,MAAM,EAAE,OAAOA,MAAM;QACzB,MAAM,IAAIC,KAAK,CAAC,yBAAyB,CAAC;MAC5C,CAAC,MAAM;QACL;QACA,MAAMrC,iBAAiB,CAAC;UAAEyB,MAAM;UAAEC,GAAG;UAAEC;QAAK,CAAC,CAAC;QAC9C,MAAMW,QAAQ,GAAG,CAAC,MAAMrC,iBAAiB,CAAC,CAAC,EAAEqB,MAAM;QACnDR,eAAe,CAACwB,QAAQ,CAAC;QACzB,OAAO;UAAEC,OAAO,EAAE,IAAI;UAAEC,OAAO,EAAE;QAAiD,CAAC;MACrF;IACF;EACF,CAAC,EAAE,EAAE,CAAC;EAEN,OAAO;IAAE/B,MAAM;IAAEE,OAAO;IAAEE,YAAY;IAAEG,kBAAkB;IAAEiB;EAAe,CAAC;AAC9E,CAAC;AAACzB,EAAA,CAtFID,cAAc;AAwFpB,eAAeA,cAAc","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}